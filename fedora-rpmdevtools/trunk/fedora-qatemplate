#! /usr/bin/python -tt
#
# File: fedora-qatemplate
# Author: Toshio Kuratomi <toshio@tiki-lounge.com>
# Date: 6 Feb, 2004
# Copyright: Toshio Kuratomi
# License: GPL
# Description: Program to automate some of the common, best practices of
# the Fedora QA Proceedure.
# Id: $Id$
"""Generates a Fedora Style QA template for a package.
Usage: fedora-qatemplate [OPTIONS] <SRC.RPM>
    -h
    --help              This usage message
    --version           Outputs version and exits
    --sha1              Use the SHA1 hash to capture file signature
    --md5               Use the MD5 hash to capture file signature
    --output=FILE       Sends output to file instead of stdout
    --discard           Discard the files extracted from the SRC.RPM
    --checkhdr          Checks the RPM header to make sure it has valid MD5s

    Not yet implemented:
    --nochecksig        Do not attempt to check the package's signature
    (Signature checking is not yet implemented)
    --checklist         Create a template with a checklist of items to check
                        useful for users new to the QA process
    
Invoke fedora-qatemplate with the name of a SRC.RPM to generate a template to
write a QA report form.  With no options it takes a SRC.RPM and generates a
template that has MD5 hashes of the src.rpm and the files it contains and
outputs this to standard out.  Unless the --discard option is given, the
program extracts the files from the source rpm into a subdirectory of the
current working directory.
"""

__programName__ = "fedora-qatemplate"
__version__ = "0.2"
__revision__ = "$Rev$"

# 8K block size for now.
BLOCKSIZE=8192

import sys, os, tempfile, stat
import string, re
import sha, md5
import getopt
# Requires python-optik w/ python2.2 or python2.3.
#from optparse import OptionParser

class InvalidCommandError(Exception):
    """Specifies an unknown option or command.
   
    Attributes:
        command -- the unknown command.

    When an unknown option is given to the program, raise the
    InvalidCommandError.
    """

    def __init__(self, command):
        self.command = command
    def __str__(self):
        return self.command

def parse_command_line(args):
    """Transform command line arguments into symbols we can act upon.

    Keyword -- arguments:
        args -- Typically, sys.argc.  A tuple of program arguments.

    Take a tuple and parse it for commands and options to the program.

        Returns --  a hash containing the commands from the command line.
    
    Keyword -- exceptions:
        ConflictingCommandsError -- There were commands to generate a new
            template mixed with commands to submit a finished template.
        InvalidComandsError -- The command line arguments don't make sense.
    """
    
    try:
        options, xtraArgs = getopt.getopt(args[1:],
        'h', ['help', 'version', 'output=', 'sha1', 'md5',
                'discard', 'checkhdr', 'checksig', 'checklist'])
    except getopt.GetoptError, (msg, opt):
        raise InvalidCommandError(opt)

    argumentMap = {'-h':'help', '--help':'help',
                    '--version':'version',
                    '-o':'output', '--output':'output',
                    '--sha1':'sha1',
                    '--md5':'md5',
                    '--discard':'keep',
                    '--checkhdr':'checkhdr',
                    '--nochecksig':'checksig',
                    '--checklist':'checklist'}
    flags={}
    # Set the input file
    if len(xtraArgs) == 1:
        flags["input"]=xtraArgs[0]
    elif len(xtraArgs) > 1:
        sys.stderr.write("Warning: %s only takes one SRPM as an argument.  Discarding the rest." % (__programName__))

    for arg in options:
        if arg == '--output':
            flags[argumentMap[arg[0]]] = arg[1]
        else:
            flags[argumentMap[arg[0]]] = arg[0]

    # Set defaults
    if not flags.has_key('keep'):
        flags['keep']=True
    else:
        flags['keep']=False
        
    if not flags.has_key('checksig'):
        flags['checksig']=True
    else:
        flags['checksig']=False
    
    if flags.has_key('checklist'):
        flags['checklist']=True
    else:
        flags['checklist']=False

    if flags.has_key('checkhdr'):
        flags['checkhdr']=True
    else:
        flags['checkhdr']=False

    if not (flags.has_key('sha1') or flags.has_key('md5')):
        flags['md5']=True
    return flags

def hash_file(input, infname, hasher):
    """Cryptographically hash a file and output the info to another file.
    
    Keyword -- arguments:
        input -- An input filehandle
        infname -- The basename of the input file
        hasher -- Hash object to use to hash the file

    Return: a one element dict with key set to filename and value to hash.
    """

    chunk=input.read(BLOCKSIZE)
    while (chunk):
        hasher.update(chunk)
        chunk=input.read(BLOCKSIZE)
    return {os.path.basename(infname) : hasher.hexdigest()}

def hash_directory(dir, hasher):
    """Cryptographically hash all the files inside a directory.
    
    Keyword -- arguments:
        dir -- Name of the directory to extract files from
        hasher -- Hash object to use to hash the file

    Returns: a dict of filenames and their hash values
    """

    fileHashes={}
    for filename in os.listdir(dir):
        hash=hasher.copy()
        srcFile=file(dir+"/"+filename, 'r')
        fileHashes.update(hash_file(srcFile, filename, hash))
        del(hash)
    return fileHashes
        
def get_hashes_from_rpm(inFileName):
    """Retrieve the hashes from the rpm headers"""
    ### FIXME: when we start using the rpm library, remove this sytem call
    ### and access the rpm headers directly
    rpmQuery=os.popen("rpm -qp --nosignature --qf '[%{filenames} %{filemd5s}\n]' "+inFileName)
    rpmHashPairs=rpmQuery.readlines()
    rpmQuery.close()

    fileHashes={}
    for hashPair in rpmHashPairs:
        (key, value) = string.split(hashPair, ' ')
        value=string.strip(value)
        fileHashes[key] = value

    return fileHashes

def perform_header_check(inFileName, fileHashes):
    """Check for malicious SRPMs by comparing the rpm md5s to the actual md5s.

    Keyword -- arguments:
        inFileName: The SRPM path/filename information
        fileHashes: MD5 hashes we computed within the SRPM

    Grabs the MD5 hashes for the files from the RPM and checks that they
    match with the checksums we computed.
    """
   
    rpmHashes=get_hashes_from_rpm(inFileName)
        
    for filename in fileHashes.keys():
        # Python 2.3 [untested]  2 lines to rm, search for <<<pop 1>>>
        #rHash=rpmHashes.pop(filename, None)
        rHash=rpmHashes.get(filename, None) # Python 2.2 <<<pop 1>>>
        
        # Hmm... Not sure if having unlisted items within the archive would
        # be totally invalid but better to check for it until I know for sure.
        if (rHash == None):
            if (filename == os.path.basename(inFileName)):
                # No reason to panic, it's just the SRPM file
                continue
            sys.stderr.write("SECURITY: %s is in the package but not listed in the rpm headers.\n" % (filename))
            sys.exit(101)
        if rHash != fileHashes[filename]:
            sys.stderr.write("SECURITY: %s has an incorrect MD5 hash in the rpm headers.\n" % (filename))
            sys.exit(102)
        del rpmHashes[filename] # Python 2.2 <<<pop 1>>>
        
    # Check if there are other files listed in the rpm that don't really exist
    if len(rpmHashes) > 0:
        sys.stderr.write("SECURITY: There are files listed in the rpm header that aren't really there.\n")
        for noFile in rpmHashes:
            sys.stderr.write(" %s\n" % (noFile))
        sys.exit(103)

if __name__ == "__main__":
    try:
        actions=parse_command_line(sys.argv)
    except InvalidCommandError, (opt):
        sys.stderr.write("-"+str(opt)+" is an unrecognized option.  Please run '"+__programName__+" --help'\n")
        sys.stderr.write("to learn what options are available.\n")
        sys.exit(2)

    # Print help or version information and exit
    if actions.has_key("help"):
        print __programName__, "version", __version__
        print __doc__
        sys.exit(0)
    if actions.has_key("version"):
        print __programName__, "version", __version__
        sys.exit(0)

    # Set up the file handle for reading
    if actions.has_key("input"):
        try:
            inputFile=file(actions["input"], 'r')
        except:
            sys.stderr.write("Unable to read from file "+actions["input"]+"\n")
            sys.exit(3)
    else:
        sys.stderr.write("You must specify an SRPM to read data from.\n")
        sys.exit(3)

    # set up file handle for output
    if actions.has_key("output"):
        try:
            outputFile=file(actions["output"], 'w')
        except:
            print stderr, "Unable to write to file",actions["output"]
            sys.exit(4)
    else:
        outputFile=sys.stdout
    
    # Output the checklist
    if actions.has_key("checklist"):
        # Write the fedora QA checklist to the outputfile in some reasonable 
        # form.  Need to figure out how to put this in so new users can use
        # it for guidance without creating a mess in the QA Bugzilla.
        pass
        
    # Output the signature checking information
    if actions["checksig"] == True:
        # For proper signature on src rpm via fedora-rpmchecksig and rpm -K
        # If badsig/nosig/badrpm print to screen and exit
        # If missing_keys, output to file and continue
        # If good sig, output to file and continue
        pass

    ### FIXME: Remove the system calls as much as possible
    ### Possibilities:
    ###  * reimplement fedora-unrpm here with an option to --unrpm only
    ###  * looks as though rpm2cpio uses some private interfaces to rpmlib
    ###    so implementing it within the script may not be practical
    ###    (or desirable)
    ###  * Should be able to extract the package name-ver-rel with rpmlib
    ###    operating on the package headers.
    rpmCmd=os.popen('rpm -qp --qf "%{NAME}-%{VERSION}-%{RELEASE}" '
                    +actions["input"], 'r')
    unpackdir=rpmCmd.readline()
    rpmCmd.close()
    # Check that we got a valid file
    # Note: Must allow output to have more than 3 '-'s in it.
    if not re.match('^.+-.+-.+$', unpackdir):
        sys.stderr.write("Received error when trying to access SRPM.  The error was:\n")
        sys.stderr.write("  %s" % (unpackdir))
        sys.exit(5)
        
    if actions["keep"] == True:
        # Output the directory here
        os.system("fedora-unrpm "+actions["input"]+"&>/dev/null")
        tempDirectory=None
    else:
        # Output to a temporary directory
        pyver=sys.version_info
        if pyver[0] <= 2 and pyver[1] <=2:
            tempDirectory=tempfile.mktemp()
            os.mkdir(tempDirectory)
            os.chmod(tempDirectory, stat.S_IRWXU)
            if os.listdir(tempDirectory):
                sys.stderr.write("SECURITY: Somebody changed the directory we were going to write into!!")
                sys.exit(100)
        else:
            # Be more secure with python 2.3 [untested]
            tempDirectory=mkdtemp()
        inFileName=os.path.abspath(actions["input"])
        os.chdir(tempDirectory)
        os.system("fedora-unrpm "+inFileName+"&>/dev/null")
        unpackdir=tempDirectory+"/"+unpackdir

    if actions.has_key("md5") or actions["checkhdr"]:
        hasher=md5.new()
        fileHashes=hash_file(inputFile, actions['input'], hasher)
        del(hasher)
        hasher=md5.new()
        fileHashes.update(hash_directory(unpackdir, hasher))
        del(hasher)
        if actions["checkhdr"]:
            # Check the rpm header against the fileHashes.
            perform_header_check(actions['input'], fileHashes)
        if actions.has_key("md5"):
            outputFile.writelines("\nMD5SUMs:\n")
            for filename in fileHashes:
                outputFile.writelines("%s  %s\n" % (fileHashes[filename], filename))

    if actions.has_key("sha1"):
        inputFile.seek(0)
        hasher=sha.new()
        fileHashes = hash_file(inputFile, actions['input'], hasher)
        del(hasher)
        hasher=sha.new()
        fileHashes.update(hash_directory(unpackdir, hasher))
        del(hasher)
        outputFile.writelines("\nSHA1SUMs:\n")
        for filename in fileHashes:
            outputFile.writelines("%s  %s\n" % (fileHashes[filename], filename))

    outputFile.close()
    inputFile.close()

    # Clean up the temporary directory
    if tempDirectory:
        for filename in os.listdir(unpackdir):
            os.unlink(unpackdir+'/'+filename)
        os.rmdir(unpackdir)
        os.rmdir(tempDirectory)

    sys.exit(0)
