#! /usr/bin/python -tt
#
# File: fedora-md5
# Author: Toshio Kuratomi <toshio@tiki-lounge.com>
# Date: 8 Feb, 2004
# Copyright: Toshio Kuratomi
# License: GPL
# Description: Program to generate MD5sums for an SRPM
# Id: $Id$
"""Generates MD5sums of an SRPM and the files within it.
Usage: fedora-md5 [OPTIONS] <SRPM>
    -h
    --help              This usage message
    --version           Outputs version and exits
    --sha1              Output sha1sums of the files
    --md5               Output md5sums of the files (default)
    --keep              Keep the files extracted from the SRC.RPM

Invoke fedora-md5 on an SRPM to generate a list of md5sums for the SRPM and
the files it contains.

The --keep option creates a subdirectory in the current directory and stores
the extracted files in it.  The default is to create the files in a temporary
location and delete them after use.

The --md5 and --sha1 options allow you to select the hashing algorithm to
use on the files.  Only one hash will be performed on a single run of the
program so the last one selected wins.  The default is to use MD5 hashing.
"""

__programName__ = "fedora-md5"
__version__ = "0.3"
__revision__ = "$Rev$"

# 8K block size for now.
BLOCKSIZE=8192

import sys, os, tempfile, stat
import string, re
import sha, md5
import getopt

class InvalidCommandError(Exception):
    """Specifies an unknown option or command.
   
    Attributes:
        command -- the unknown command.

    When an unknown option is given to the program, raise the
    InvalidCommandError.
    """

    def __init__(self, command):
        self.command = command
    def __str__(self):
        return self.command

def parse_command_line(args):
    """Transform command line arguments into symbols we can act upon.

    Keyword -- arguments:
        args -- Typically, sys.argc.  A tuple of program arguments.

    Take a tuple and parse it for commands and options to the program.

        Returns --  a hash containing the commands from the command line.
    
    Keyword -- exceptions:
        ConflictingCommandsError -- There were commands to generate a new
            template mixed with commands to submit a finished template.
        InvalidComandsError -- The command line arguments don't make sense.
    """
    
    try:
        options, xtraArgs = getopt.getopt(args[1:],
        'h', ['help', 'version', 'sha1', 'md5', 'keep'])
    except getopt.GetoptError, (msg, opt):
        raise InvalidCommandError(opt)

    argumentMap = {'-h':'help', '--help':'help',
                    '--version':'version',
                    '--keep':'keep',
                    '--sha1':'hash',
                    '--md5':'hash'}
    flags={}

    # Set the input file
    if len(xtraArgs) >= 1:
        if len(xtraArgs) >1:
            sys.stderr.write("Warning: This version of fedora-md5 only operates on the first filename.\n")
            sys.stderr.write("         Ignoring the other arguments.\n")
        flags["input"]=os.path.abspath(xtraArgs[0])

    for arg in options:
        flags[argumentMap[arg[0]]] = arg[0]

    # Default values and cleanups to boolean values where appropriate
    if flags.setdefault('keep', False):
        flags['keep'] = True
    flags.setdefault('hash', '--md5')

    # Currently no command line flag to disable this but the code to disable
    # it is there.  [untested]
    flags.setdefault('headercheck', True)

    return flags

def hash_file(input, infname, hasher):
    """Cryptographically hash a file and output the info to another file.
    
    Keyword -- arguments:
        input -- An input filehandle
        infname -- The basename of the input file
        hasher -- Hash object to use to hash the file

    Return: a one element dict with key set to filename and value to hash.
    """

    chunk=input.read(BLOCKSIZE)
    while (chunk):
        hasher.update(chunk)
        chunk=input.read(BLOCKSIZE)
    return {os.path.basename(infname) : hasher.hexdigest()}

def hash_directory(dir, hasher):
    """Cryptographically hash all the files inside a directory.
    
    Keyword -- arguments:
        dir -- Name of the directory to extract files from
        hasher -- Hash object to use to hash the file

    Returns: a dict of filenames and their hash values
    """

    fileHashes={}
    for filename in os.listdir(dir):
        hash=hasher.copy()
        srcFile=file(dir+"/"+filename, 'r')
        fileHashes.update(hash_file(srcFile, filename, hash))
        del(hash)
    return fileHashes
        
def get_hashes_from_rpm(inFileName):
    """Retrieve the hashes from the rpm headers"""
    ### FIXME: when we start using the rpm library, remove this sytem call
    ### and access the rpm headers directly
    rpmQuery=os.popen("rpm -qp --nosignature --qf '[%{filenames} %{filemd5s}\n]' "+inFileName)
    rpmHashPairs=rpmQuery.readlines()
    rpmQuery.close()

    fileHashes={}
    for hashPair in rpmHashPairs:
        (key, value) = string.split(hashPair, ' ')
        value=string.strip(value)
        fileHashes[key] = value

    return fileHashes

def perform_header_check(inFileName, fileHashes):
    """Check for malicious SRPMs by comparing the rpm md5s to the actual md5s.

    Keyword -- arguments:
        inFileName: The SRPM path/filename information
        fileHashes: MD5 hashes we computed within the SRPM

    Grabs the MD5 hashes for the files from the RPM and checks that they
    match with the checksums we computed.
    """
   
    rpmHashes=get_hashes_from_rpm(inFileName)
        
    for file in fileHashes.keys():
        # Python 2.3 [untested]  2 lines to rm, search for <<<pop 1>>>
        #rHash=rpmHashes.pop(file, None)
        rHash=rpmHashes.get(file, None) # Python 2.2 <<<pop 1>>>
        
        # Hmm... Not sure if having unlisted items within the archive would
        # be totally invalid but better to check for it until I know for sure.
        if (rHash == None):
            if (file == os.path.basename(inFileName)):
                # No reason to panic, it's just the SRPM file
                continue
            sys.stderr.write("SECURITY: %s is in the package but not listed in the rpm headers.\n" % (file))
            sys.exit(101)
        if rHash != fileHashes[file]:
            sys.stderr.write("SECURITY: %s has an incorrect MD5 hash in the rpm headers.\n" % (file))
            sys.exit(102)
        del rpmHashes[file] # Python 2.2 <<<pop 1>>>
        
    # Check if there are other files listed in the rpm that don't really exist
    if len(rpmHashes) > 0:
        sys.stderr.write("SECURITY: There are files listed in the rpm header that aren't really there.\n")
        for noFile in rpmHashes:
            sys.stderr.write(" %s\n" % (noFile))
        sys.exit(103)
    
if __name__ == "__main__":
    try:
        actions=parse_command_line(sys.argv)
    except InvalidCommandError, (opt):
        sys.stderr.write("-"+str(opt)+" is an unrecognized option.  Please run '"+__programName__+" --help'\n")
        sys.stderr.write("to learn what options are available.\n")
        sys.exit(2)

    # Print help or version information and exit
    if actions.has_key("help"):
        print __programName__, "version", __version__
        print __doc__
        sys.exit(0)
    if actions.has_key("version"):
        print __programName__, "version", __version__
        sys.exit(0)

    # Set up the file handle for reading
    if actions.has_key("input"):
        try:
            inputFile=file(actions["input"], 'r')
        except:
            sys.stderr.write("Unable to read from file "+actions["input"]+"\n")
            sys.exit(3)
    else:
        sys.stderr.write("You must specify an SRPM to read data from.\n")
        sys.exit(3)

    ### FIXME: os.system => rpmlib conversion
    rpmCmd=os.popen('rpm -qp --qf "%{NAME}-%{VERSION}-%{RELEASE}" '
                    +actions["input"], 'r')
    unpackdir=rpmCmd.readline()
    rpmCmd.close()
    # Check that we got a valid file
    # Note: Must allow output to have more than 3 '-'s in it.
    if not re.match('^.+-.+-.+$', unpackdir):
        sys.stderr.write("Received error when trying to access SRPM.  The error was:\n")
        sys.stderr.write("  %s" % (unpackdir))
        sys.exit(5)
        
    if actions["keep"] == True:
        # Output the directory here
        os.system("fedora-unrpm "+actions["input"]+"&>/dev/null")
        tempDirectory=None
    else:
        # Output to a temporary directory
        pyver=sys.version_info
        if pyver[0] <= 2 and pyver[1] <=2:
            tempDirectory=tempfile.mktemp()
            os.mkdir(tempDirectory)
            os.chmod(tempDirectory, stat.S_IRWXU)
            if os.listdir(tempDirectory):
                sys.stderr.write("SECURITY: Somebody changed the directory we were going to write into!!")
                sys.exit(100)
        else:
            # Be more secure with python 2.3 [untested]
            tempDirectory=mkdtemp()
        inFileName=os.path.abspath(actions["input"])
        os.chdir(tempDirectory)
        os.system("fedora-unrpm "+inFileName+"&>/dev/null")
        unpackdir=tempDirectory+"/"+unpackdir
    
    # Order of the next three sections is important.  We take the md5 hash
    # for comparison with the rpm headers.  Then if sha1 was requested, we
    # overwrite the md5 hashes in the fileHashes dict with sha hashes.
    if actions['hash'] == '--md5' or actions['headercheck'] == True:
        hasher=md5.new()
        fileHashes = hash_file(inputFile, actions['input'], hasher)
        del(hasher)
        hasher=md5.new()
        fileHashes.update(hash_directory(unpackdir, hasher))
        del(hasher)
        
    if actions['headercheck'] == True:
        perform_header_check(actions['input'], fileHashes)
        
    if actions['hash'] == '--sha1':
        inputFile.seek(0)
        hasher=sha.new()
        fileHashes = hash_file(inputFile, actions['input'], hasher)
        del(hasher)
        hasher=sha.new()
        fileHashes.update(hash_directory(unpackdir, hasher))
        del(hasher)

    # Print our fileHashes
    for file in fileHashes.keys():
        print "%s  %s" % (fileHashes[file], file)
    
    inputFile.close()

    # Clean up the temporary directory
    if tempDirectory:
        for file in os.listdir(unpackdir):
            os.unlink(unpackdir+'/'+file)
        os.rmdir(unpackdir)
        os.rmdir(tempDirectory)

    sys.exit(0)
