Preferences to Add Via GConf
============================

:Author: Toshio Kuratomi <toshio-tiki-lounge.com>
:Date: $Date$

.. contents::

Preferences
-----------
All currently needed preferences have been implemented.
Infrastructure exists and seems workable.

Druid
-----
In the new scheme of things we need to know what checklist to load before we
can do useful things.  Once we know what checklist to load, we should be able
to invoke functions to take onLoad information from users.

The Druid will have the following pathways:

1) Info screen.
2) (A) Load savefile (B) New checklist
3) A) Open a file chooser with the CWD for the user to pick from
   B) Open a selector of the system installed checklists
4) Load checklist.  Display a properties dialog to get the properties that
   the checklist requires (onLoad) if any.
5) Start the program.

When loading a new checklist after the program is started, we should skip
1 & 2 and go directly to 3A.

When loading a saved checklist we want to popup a file selector (could be
the Druid page or the Druid file selector could be the load checklist file
selector.)  Then proceed to 4pre.

Properties
----------
    # Output:
    # Three consumers:
    #   - CheckList needs to convert into XML
    #   - PropertiesWidget needs to convert into list of labels/entry boxes.
    #   - Functions need to get values from individual properties and set them
    #     for others.
    # How best to handle this?
    # CheckList:
    # for propKey in props.keys():
    #       info = props[propKey]
Properties are set on the checklist.  The checklist type should provide a
set of properties that are legal.  Perhaps implement as GObject values on
the checklist object (Can't do this as it isn't extensible.  The checklist
may have arbitrary properties.  Specifying in GObject makes them a
"compiletime" rather than run-time setting.)

* MD5Sums
* Bugzilla URL
* SRPM to check
* QA checklist loaded

We have a properties dict in the CheckList right now.
What are we going to do with that?

We need the following attributes on functions:

* automatic/userinput/useroverride
* onLoad(Mandatory before we start)/onPublish(mandatory before we end)/optional

The current checklist.dtd encapsulates these in the following ways.  As
RequireTypes:

* onLoad (start, user)
* onPublish (end, user)
* automatic (when its dependencies resolve, automatic)
* optional (optional, user)

overrides are implemented as user invocable functions.

Properties widget that allows setting the properties (properties.py)

Properties data structure that is set from checklist and used by the widget
and the functions.  The functions are a set of methods 

::
  class Checklist():
    Has a Properties.

  class Properties(dict):
    __init__()
    clear()
    set(name, value)
    add(name, value=None)
    output() sorted list of Properties.
    
  class PropertiesWidget():
    __init__(self, model=None):
    set_model(model)

Functions
---------
::
  class Functions():
    __init__(self, Properties):
    clear()
    add(name, args, type)
    output(xmlNode)
    menuFunctions()
    do(string FuncName)

  class FunctionsMenu():
    __init__(self, model=None)
    set_model()

  class FedoraUSFunctions(Functions):
    Functions.__init__(self, Properties)
    SRPMReview()
    

Functions are tied into properties.  Both are declared by the checklist.
Properties are defined in the checklist while functions are defined in code
modules.  Functions can operate on Properties.  And they can take properties
as arguments.

So each Function module has to have access to the checklist's properties.
How?

Also, properties may be set from functions.  So we have the following
dependence::

  Func_foo (Prop_A) -> Prop_B
  When Prop_A.set() -> Call Func_foo() Prop_B.set()
  FunctionClass has a Properties.
  Prop_A.set():
  	function_list = Properties.propset[Prop_A]
	for func in function_list:
		Functions.invoke(func)
  class SpecificFuncClass(FuncClass):
  	def invoke(funcName):
		eval('self.'+funcName)
	def funcName():
		set Prop_B = Prop_A
  
Most functions are selectable from a menu entry.  How does this affect
things?  We need to create a menu from the functions and assign the
functions as callbacks.  The functions in the menu need to have access to
the properties.  They also need to use functions on the review (publish) and
gconf things (Enable/disable treetips)

Create a QAMenu class that takes the checklist as its model.  When the 

Functions that are not in the menu are functions used by the properties
themselves.  These functions often need to specify dependency information on
other properties.

Other things that get set depending on the checklist:

* Application's title bar: app.set_title()
* Appplication's status bar: app.mainWinAppBar.push()

  - Ideas for statusbar info:

    + The main identifier of the review (SRPM name)
    + Number of pass/fail/needs-reviewing/etc

* So we don't have to inline all our code, we probably want to have a method
  to callout to other code.  Maybe there should be a certain set of standard
  functions.  Then we can add per checklist functions in a separate file.  The
  checklist can let us know which functions its using via a name/sha1sum pair.
  They can then reference the functions in that external file.
